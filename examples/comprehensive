# -*- python -*-

# This example is complete with exceptions for less normal colour
# curve modifiers: nothing else than CIE 1964 10 degree CMF for
# colour temperature, not use of temporarly linear RGB curves,
# negative image, inverted image, sigmoid correction, or free
# function modifier. Neither does it support multiple screens,
# this is normally not an issue because Xinerama is normally used
# to put all monitors on the same screen; nor does it parse
# ad-hoc settings


# Geographical coodinates.
# (KTH building D computer laboratories in this example.)
latitude, longitude = 59.3472, 18.0728

# Custom dayness by time settings.
time_alpha = [['02:00', 0], ['08:00', 1], ['22:00', 1]]


def by_time():
    '''
    Dayness calculation using time
    '''
    global time_alpha
    if isinstance(time_alpha[0][0], str):
        for i in range(len(time_alpha)):
            hh = [float(x) for x in time_alpha[i][0].split(':')]
            hh = sum([hh[j] / 60 ** j for j in range(len(hh))])
            time_alpha[i][0] = hh
    now = datetime.datetime.now()
    hh = now.hour + now.minute / 60 + now.second / 60 ** 2
    for i in range(len(time_alpha)):
        (a, av) = time_alpha[i]
        (b, bv) = time_alpha[(i + 1) % len(time_alpha)]
        if a < hh:  a += 24
        if b < hh:  b += 24
        if a <= hh <= b:
            hh = (hh - a) / (b - a)
            return av * (1 - hh) + bv * hh
    return 1 # Error in `time_alpha` (probably)


# Keep uncomment to use solar position.
get_dayness = lambda : sun(latitude, longitude)
# Uncomment to use time of day.
#get_dayness = by_time
# Uncomment if you do not want continuous mode, high night values are used.
#get_dayness = None


# The (zero-based) index of the monitors (CRTC:s) to apply
# settings to. An empty list means that all monitors are used,
# but all monitors will have the same settings.
monitors = []


# The following settings are lists. This is to allow you to
# use different settings on different monitors. For example,
# `gamma_red_day = [1]`, this means that during high day, the
# red gamma is 1 on all monitors. But if we change this to
# `gamma_red_day = [1.0, 1.1]`, the first monitor will have
# the red gamma set to 1,0 and the second monitor will have
# the red gamma set to 1,1. If you have more monitors than
# used in the settings modulo division will be used. For
# instance, if you have four monitors, the third monitor will
# have the same settings as the first monitor, and the fourth
# monitor will have the same settings as the second monitor.


# Colour temperature at high day and high night, respectively.
temperature_day, temperature_night = [6500], [3700]


# Colour brightness at high day and high night, respectively.
# This setting uses the CIE xyY colour space for calculating values.
brightness_day, brightness_night = [1], [1]

# Colour brightness of the red, green and blue components,
# respectively, at high day and high night, respectively.
# This settings uses the sRGB colour space for calculating values.
brightness_red_day, brightness_red_night = [1], [1]
brightness_green_day, brightness_green_night = [1], [1]
brightness_blue_day, brightness_blue_night = [1], [1]


# Colour contrast at high day and high night, respectively.
# This setting uses the CIE xyY colour space for calculating values.
contrast_day, contrast_night = [1], [1]

# Colour contrast of the red, green and blue components,
# respectively, at high day and high night, respectively.
# This settings uses the sRGB colour space for calculating values.
contrast_red_day, contrast_red_night = [1], [1]
contrast_green_day, contrast_green_night = [1], [1]
contrast_blue_day, contrast_blue_night = [1], [1]


# Note: brightness and contrast is not intended for colour
# calibration, it should be calibrated on the monitors'
# control panels.


# Gamma correction for the red, green and blue components, respectively,
# at high day, high night and monitor default, respectively.
# This settings uses the sRGB colour space for calculating values.
gamma_red_day, gamma_red_night, gamma_red_default = [1], [1], [1]
gamma_green_day, gamma_green_night, gamma_green_default = [1], [1], [1]
gamma_blue_day, gamma_blue_night, gamma_blue_default = [1], [1], [1]


# Note: gamma is supposted to be static, it purpose is to
# correct the colours on the monitors the monitor's gamma
# is exactly 2,2 and the colours look correct in relation
# too each other. It is supported to have different settings
# at day and night because there are no technical limitings
# and it can presumable increase readability on text when
# the colour temperature is low.


# ICC profile for video filtering and monitor calibration, respectively.
# Replace `None` with the pathname of the profile. It is assume that
# the calibration profile is already applied and that you want it to
# still be applied on exit.
icc_video_filter_profile = [None]
icc_calibration_profile = [None]


# Function for getting the current the current monitor calibration.
# If `None` the the current monitor calibration will be ignored.
# `if not panicgate:` is included to ignore monitor calibration if
# -p (--panicgate) is used.
current_calibration = [None]
if not panicgate:
    #calib_get = None
    calib_get = randr_get
    #calib_get = vidmode_get
    current_calibration = [calib_get]


# These are fun curve manipulator settings that lowers the
# colour resolution. `red_x_resolution` is the number of colours
# colours there are one encoding axis of the red curve.
# `red_y_resolution` is how many colours there are on the
# output axis of the red curve.
red_x_resolution, red_y_resolution = [i_size], [o_size]
green_x_resolution, green_y_resolution = [i_size], [o_size]
blue_x_resolution, blue_y_resolution = [i_size], [o_size]


# Loads the current monitor calibrations.
m = 0
for i in range(len(current_calibration)):
    f = current_calibration[i]
    if f is not None:
        if len(monitors) == 0:
            m = monitors[i % len(monitors)]
        current_calibration[i] = f(m)


monitor_controller = lambda : randr(*monitors)
'''
:()→void  Function used by Blueshift on exit to apply reset colour curves, if using preimplemented `reset`
'''


uses_adhoc_opts = False
'''
:bool  `True` if the configuration screens parses the ad-hoc settings
'''


last_dayness = None
def periodically(year, month, day, hour, minute, second, weekday, fade):
    '''
    :(int, int, int, int, int, int, int, float?)?→void  Place holder for periodically invoked function
    
    Invoked periodically
    
    If you want to control at what to invoke this function next time
    you can set the value of the global variable `wait_period` to the
    number of seconds to wait before invoking this function again.
    The value does not need to be an integer.
    
    @param   year:int     The year
    @param   month:int    The month, 1 = January, 12 = December
    @param   day:int      The day, minimum value is 1, probable maximum value is 31 (*)
    @param   hour:int     The hour, minimum value is 0, maximum value is 23
    @param   minute:int   The minute, minimum value is 0, maximum value is 59
    @param   second:int   The second, minimum value is 0, probable maximum value is 60 (**)
    @param   weekday:int  The weekday, 1 = Monday, 7 = Sunday
    @param   fade:float?  Blueshift can use this function to fade into a state when it start
                          or exits. `fade` can either be negative, zero or positive or `None`,
                          but the magnitude of value cannot exceed 1. When Blueshift starts,
                          this function will be invoked multiple with the time parameters
                          of the time it is invoked and each time `fade` will increase towards
                          1, starting at 0, when the value is 1, the settings should be applied
                          to 100 %. After this this function will be invoked once again with
                         `fade` being `None`. When Blueshift exits the same behaviour is used
                          except, `fade` decrease towards -1 but start slightly below 0, when
                          -1 is reached all settings should be normal. Then Blueshift will NOT
                          invoke this function with `fade` being `None`, instead it will by
                          itself revert all settings and quit.
    
    (*)  Can be exceeded if the calendar system is changed, like in 1712-(02)Feb-30
    (**) See https://en.wikipedia.org/wiki/Leap_second
    '''
    global last_dayness, wait_period
    
    dayness = get_dayness()
    # Do not do unnecessary work.
    if fade is None:
        if dayness == last_dayness:
            return
        last_dayness = dayness
    
    # Help functions for colour interpolation.
    interpol = lambda _day, _night : _day[m % len(_day)] * dayness + _night[m % len(_night)] * (1 - dayness)
    purify = lambda current, pure : current * alpha + pure * (1 - alpha)
    
    for m in range(max(1, len(monitors))):
        temperature_      = interpol(temperature_day,      temperature_night)
        brightness_       = interpol(brightness_day,       brightness_night)
        brightness_red_   = interpol(brightness_red_day,   brightness_red_night)
        brightness_green_ = interpol(brightness_green_day, brightness_green_night)
        brightness_blue_  = interpol(brightness_blue_day,  brightness_blue_night)
        contrast_         = interpol(contrast_day,         contrast_night)
        contrast_red_     = interpol(contrast_red_day,     contrast_red_night)
        contrast_green_   = interpol(contrast_green_day,   contrast_green_night)
        contrast_blue_    = interpol(contrast_blue_day,    contrast_blue_night)
        gamma_red_        = interpol(gamma_red_day,        gamma_red_night)
        gamma_green_      = interpol(gamma_green_day,      gamma_green_night)
        gamma_blue_       = interpol(gamma_blue_day,       gamma_blue_night)
        if fade is not None:
            alpha = abs(fade)
            temperature_      = purify(temperature_,      6500)
            brightness_       = purify(brightness_,       1)
            brightness_red_   = purify(brightness_red_,   1)
            brightness_green_ = purify(brightness_green_, 1)
            brightness_blue_  = purify(brightness_blue_,  1)
            contrast_         = purify(contrast_,         1)
            contrast_red_     = purify(contrast_red_,     1)
            contrast_green_   = purify(contrast_green_,   1)
            contrast_blue_    = purify(contrast_blue_,    1)
            gamma_red_        = purify(gamma_red_,        gamma_red_default  [m % len(gamma_red_default)])
            gamma_green_      = purify(gamma_green_,      gamma_green_default[m % len(gamma_green_default)])
            gamma_blue_       = purify(gamma_blue_,       gamma_blue_default [m % len(gamma_blue_default)])
        
        # Remove settings from last run.
        start_over()
        
        # Apply ICC profile as a video filter.
        i = m % len(icc_video_filter_profile)
        if icc_video_filter_profile[i] is not None:
            if isinstance(icc_video_filter_profile[i], str):
                icc_video_filter_profile[i] = load_icc(icc_video_filter_profile[i])
            icc_video_filter_profile[i]()
            # Fade in/out filter
            if fade is not None:
                alpha = abs(fade)
                for curve in (r_curve, g_curve, b_curve):
                    for i in range(i_size):
                        curve[i] = purify(curve[i], i / (i_size - 1))
        
        # Apply colour temperature using raw CIE 1964 10 degree CMF data with interpolation.
        temperature(temperature_, lambda t : divide_by_maximum(cmf_10deg(t)))
        
        # Apply calibration used when started.
        c = current_calibration[m % len(current_calibration)]
        if c is not None:
            c()
        
        # Apply colour brightness using the CIE xyY colour space.
        cie_brightness(brightness_)
        # Apply colour brightness using the sRGB colour space.
        # If we only used one parameter, it would be applied to all colour components.
        rgb_brightness(brightness_red_, brightness_green_, brightness_blue_)
        
        # Apply colour contrast using the CIE xyY colour space.
        cie_contrast(contrast_)
        # Apply colour contrast using the sRGB colour space.
        # If we only used one parameter, it would be applied to all colour components.
        rgb_contrast(contrast_red_, contrast_green_, contrast_blue_)
        
        # Apply low colour resolution emulation.
        rx = red_x_resolution[m % len(red_x_resolution)]
        ry = red_y_resolution[m % len(red_y_resolution)]
        gx = green_x_resolution[m % len(green_x_resolution)]
        gy = green_y_resolution[m % len(green_y_resolution)]
        bx = blue_x_resolution[m % len(blue_x_resolution)]
        by = blue_y_resolution[m % len(blue_y_resolution)]
        lower_resolution(rx, ry, gx, gy, bx, by)
        
        # Clip colour curves to fit [0, 1] to avoid errors by complex numbers.
        clip()
        
        # Apply gamma correction to monitor.
        gamma(gamma_red_, gamma_green_, gamma_blue_)
        
        # Apply ICC profile as a monitor calibration.
        i = m % len(icc_calibration_profile)
        if icc_calibration_profile[i] is not None:
            if isinstance(icc_calibration_profile[i], str):
                icc_calibration_profile[i] = load_icc(icc_calibration_profile[i])
            icc_calibration_profile[i]()
        
        # Flush settings to monitor.
        if len(monitors) == 0:
            randr()
        else:
            randr(monitors[m % len(monitors)])
    
    # Lets wait only 5 seconds, instead of a minute before running again.
    wait_period = 10


def reset():
    '''
    Invoked to reset the displays
    '''
    for m in range(max(1, len(monitors))):
        gamma_red_   = gamma_red_default  [m % len(gamma_red_default)]
        gamma_green_ = gamma_green_default[m % len(gamma_green_default)]
        gamma_blue_  = gamma_blue_default [m % len(gamma_blue_default)]
        
        # Remove settings from last run.
        start_over()
        
        # Apply calibration used when started.
        c = current_calibration[m % len(current_calibration)]
        if c is not None:
            c()
        
        # Apply gamma correction to monitor.
        gamma(gamma_red_, gamma_green_, gamma_blue_)
        
        # Apply ICC profile as a monitor calibration.
        i = m % len(icc_calibration_profile)
        if icc_calibration_profile[i] is not None:
            if isinstance(icc_calibration_profile[i], str):
                icc_calibration_profile[i] = load_icc(icc_calibration_profile[i])
            icc_calibration_profile[i]()
        
        # Flush settings to monitor.
        if len(monitors) == 0:
            randr()
        else:
            randr(monitors[m % len(monitors)])


if get_dayness is not None:
    # Set transition time, 0 on high day and 5 seconds on high night.
    fadein_time = 5 * (1 - get_dayness())
    # Do 10 changes per second.
    fadein_steps = fadein_time * 10
    
    # Transition on exit in the same way, calculated on exit.
    old_signal_SIGTERM = signal_SIGTERM
    if 'SIGTERM' not in conf_storage:
        conf_storage['SIGTERM'] = old_signal_SIGTERM
    else:
        old_signal_SIGTERM = conf_storage['SIGTERM']
    def signal_SIGTERM(signum, frame):
        global fadeout_time, fadeout_steps
        fadeout_time = 5 * (1 - get_dayness())
        fadeout_steps = fadeout_time * 10
        old_signal_SIGTERM(signum, frame)
else:
    # Do not use continuous mode.
    get_dayness = lambda : 0
    def apply(fade):
        t = datetime.datetime.now()
        wd = t.isocalendar()[2]
        periodically(t.year, t.month, t.day, t.hour, t.minute, t.second, wd, fade)
    if not panicgate:
        signal.signal(signal.SIGTERM, signal_SIGTERM)
        trans = 0
        apply(trans)
        while running:
            time.sleep(0.1)
            if trans >= 1:
                break
            trans += 0.05
            apply(trans)
    apply(None)
    periodically = None

