# -*- python -*-

# This example reads an lisp-esque syntax configuration
# file to make it easier for non-programmers to use
# Blueshift. It will read a file with the same pathname
# just with ‘.conf’ appended (‘lisp-esque.conf’ in this
# case.) However, if the filename of this file ends with
# with ‘rc’, that part will be removed, for example, if
# you rename this script to ‘~/.blueshiftrc’ it will read
# ‘~/.blueshift.conf’ rather than ‘~/.blueshiftrc.conf’.


# Copyright © 2014  Mattias Andrée (maandree@member.fsf.org)
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys


# Get the name of .conf file
conf = '%s.conf' % (config_file[:-2] if config_file.endswith('rc') else config_file)


# Read .conf file
with open(conf, 'r') as file:
    conf = file.read()


def abort(text, returncode = 1):
    '''
    Abort the program
    
    @param   text:str        Error message
    @return  returncode:int  The programs return code
    '''
    printerr('\033[01;31m%s\033[00m' % text)
    sys.exit(returncode)


def parse(code):
    '''
    Parse the .conf file and return it as a tree
    
    @param   code:str      The .conf file content to parse
    @return  :list<↑|str>  The root node in the tree
    '''
    stack, stackptr = [], -1
    comment, escape, quote, buf = False, False, None, None
    col, char, line = 0, 0, 1
    
    for c in code:
        if comment:
            if c in '\n\r\f':
                comment = False
        elif escape:
            escape = False
            if   c == 'a':  buf += '\a'
            elif c == 'b':  buf += chr(8)
            elif c == 'e':  buf += '\033'
            elif c == 'f':  buf += '\f'
            elif c == 'n':  buf += '\n'
            elif c == 'r':  buf += '\r'
            elif c == 't':  buf += '\t'
            elif c == 'v':  buf += chr(11)
            elif c == '0':  buf += '\0'
            else:
                buf += c
        elif c == quote:
            quote = None
        elif (c in ';#') and (quote is None):
            if buf is not None:
                stack[stackptr].append(buf)
                buf = None
            comment = True
        elif (c == '(') and (quote is None):
            if buf is not None:
                stack[stackptr].append(buf)
                buf = None
            stackptr += 1
            if stackptr == len(stack):
                stack.append([])
            else:
                stack[stackptr] = []
        elif (c == ')') and (quote is None):
            if buf is not None:
                stack[stackptr].append(buf)
                buf = None
            if stackptr == 0:
                return stack[0]
            stackptr -= 1
            stack[stackptr].append(stack[stackptr + 1])
        elif (c in ' \t\n\r\f') and (quote is None):
            if buf is not None:
                stack[stackptr].append(buf)
                buf = None
        else:
            if buf is None:
                buf = ''
            if c == '\\':
                escape = True
            elif (c in '\'\"') and (quote is None):
                quote = c
            else:
                buf += c
        
        if c == '\t':
            col |= 7
        col += 1
        char += 1
        if c in '\n\r\f':
            line += 1
            col = 0
            char = 0
    
    abort('premature end of file')


# Parse .conf file in tree
conf = parse(conf)


# Parse .conf file tree
if isinstance(conf[0], str) and not conf[0].startswith(':'):
    conf = conf[1:]


# Available outputs
screens = list_screens('drm' if ttymode else 'randr')

# Map of composed function
composed = {}

# List of adjustments
adjustments = []


## For the following functions, the type of args is the type of args
## after it has been evaluated, they may be functions inside that
## break this until the functions have been evaluated. The type for
## args before evaluation is always list<↑|str>.

def _monitors(mods, args):
    '''
    Select monitors to use by index
    
    @param  mods:[]         Not used
    @param  args:list<str>  Indices of outputs, <screen>: or <screen>:<output> or 'nil', empty for all
    '''
    args = evaluate_tree(args, True)
    print('Selected monitors: %s' % ', '.join(args))


def _crtc(mods, args):
    '''
    Find monitors by name
    
    @param   mods:[]|[str]   Optionally the number of monitors to list
    @param   args:list<str>  Names of outputs
    @return  :list<str>      <screen>:<output> encoding of found monitors
    '''
    args = evaluate_tree(args, False)
    limit = None if len(mods) == 0 else int(mods[0])
    found = []
    for name in args:
        found += screens.find_by_name(name)
    found = ['%i:%i' % (output.screen, output.crtc) for output in found]
    if limit is not None:
        found += ['nil'] * limit
        found = found[:limit]
    return found


def _size(mods, args):
    '''
    Find monitors by physical size
    
    @param   mods:[]|[str]                     Optionally the number of monitors to list
    @param   args:[str, str]|list<[str, str]>  Width–height-pairs, in millimetres
    @return  :list<str>                        <screen>:<output> encoding of found monitors
    '''
    args = evaluate_tree(args, True)
    limit = None if len(mods) == 0 else int(mods[0])
    found = []
    for (width, height) in [args] if len(args) == 2 else args:
        found += screens.find_by_size(int(width), int(height))
    found = ['%i:%i' % (output.screen, output.crtc) for output in found]
    if limit is not None:
        found += ['nil'] * limit
        found = found[:limit]
    return found


def _edid(mods, args):
    '''
    Find monitors by extended display identification data
    
    @param   mods:[]|[str]   Optionally the number of monitors to list
    @param   args:list<str>  EDID of outputs' monitors
    @return  :list<str>      <screen>:<output> encoding of found monitors
    '''
    args = evaluate_tree(args, False)
    limit = None if len(mods) == 0 else int(mods[0])
    found = []
    for edid in args:
        found += screens.find_by_edid(edid)
    found = ['%i:%i' % (output.screen, output.crtc) for output in found]
    if limit is not None:
        found += ['nil'] * limit
        found = found[:limit]
    return found


def _coordinates(mods, args):
    '''
    Specify geographical location by coordinates
    
    @param  mods:[]|[str]    Continuously updates if 'cont' is included
    @param  args:[str, str]  The latitude and longitude (northwards and eastwards in degrees)
    '''
    args = evaluate_tree(args, True)
    if 'cont' in mods:
        print('Selected continuous location tracking: %s' % repr(args))
    else:
        print('Selected location: %f, %f' % (float(args[0]), float(args[1])))


def _parse(mods, args):
    '''
    Parse a string into a tree
    
    @param   mods:[]       Not used
    @param   args:[str]    The string
    @return  :list<↑|str>  The tree
    '''
    args = evaluate_tree(args, True)
    if len(args) == 1:
        return evaluate_tree(parse(args[0]))
    else:
        return [evaluate_tree(parse(arg)) for arg in args]


def _read(mods, args):
    '''
    Read an external file
    
    @param   mods:[]     Not used
    @param   args:[str]  The file
    @return  :[str]      The content of the file
    '''
    args = evaluate_tree(args, False)
    rc = []
    for arg in args:
        with open(arg, 'r') as file:
            rc.append(file.read().rstrip())
    return rc


def _spawn(mods, args):
    '''
    Run an external command
    
    @param   mods:[]         Not used
    @param   args:list<str>  The command
    @return  :[str]          The output of the command
    '''
    args = evaluate_tree(args, False)
    from subprocess import Popen, PIPE
    return [subprocess.Popen(args, stdout = PIPE, stderr = sys.stderr).proc.communicate()[0]]


def _include(mods, args):
    '''
    Include external files
    
    @param   mods:[]         Not used
    @param   args:list<str>  The files
    @return  :list<↑|str>    The content of the file as a tree concatenated
    '''
    args = evaluate_tree(args, False)
    rc = []
    for arg in args:
        with open(arg, 'r') as file:
            rc.append(file.read().rstrip())
    if len(rc) == 1:
        return evaluate_tree(parse(rc[0]))
    else:
        return [evaluate_tree(parse(content)) for content in rc]


def _source(mods, args):
    '''
    Load external Python files
    
    @param   mods:[]         Not used
    @param   args:list<str>  The files
    '''
    args = evaluate_tree(args, True)
    pass # TODO (source)


def _eval(mods, args):
    '''
    Evaluate strings of Python code
    
    @param   mods:[]           Not used
    @param   args:list<↑|str>  The strings
    @return  :list<↑|str>      The evaluated valus
    '''
    args = evaluate_tree(args, False)
    def eval_(arg):
        if isinstance(arg, str):
            return str(eval(arg, globals()))
        else:
            return [eval_(arg) for arg in args]
    return eval_(args)


def _timepoints(mods, args):
    '''
    Select time points when different settings are applied,
    continuous transition betweem them will be used. This are
    not used by default, be can be enabled in the next section.
    
    @param  mods:[]         Not used
    @param  args:list<str>  The time points in 24-hour colour formatted as
                            H, H:M or H:M:S, leading zeroes are allowed
    '''
    args = evaluate_tree(args, True)
    print('Selected time points: %s' % ', '.join(args))


def _points(mods, args):
    '''
    Select method for calculating the time the different settings are (fully) applied
    
    @param  mods:[]         Not used
    @param  args:list<str>  Either 'solar' optionally followed by solar
                            elevation in degrees, 'time' or 'constant'
    '''
    args = evaluate_tree(args, True)
    print('Selected points: %s' % ', '.join(args))


def _dayness(mods, args):
    '''
    Configure so that adjustments only need day and night settings, time
    settings application points are reduced to different degrees of these
    settings
    
    @param  mods:[]         Not used
    @param  args:list<str>  Mapping from points (implied by index) to dayness degrees
    '''
    args = evaluate_tree(args, True)
    print('Selected dayness: %s' % ', '.join(args))


def _method(mods, args):
    '''
    Select colour curve applying method
    
    @param  mods:[]         Not used
    @param  args:list<str>  The methods to use: 'randr', 'vidmode', 'print'
    '''
    args = evaluate_tree(args, True)
    if ttymode:
        args = ['drm' if arg in ['randr', 'vidmode'] else arg for arg in args]
    print('Selected methods: %s' % ', '.join(args))


def _transfrom(mods, args):
    '''
    Let Blueshift transition from the currently applied settings when it starts
    
    @param  mods:[]         Not used
    @param  args:list<str>  Method for (optionally) each monitor: 'randr', 'vidmode' or 'nil'
    '''
    args = evaluate_tree(args, True)
    if ttymode:
        args = ['drm' if arg in ['randr', 'vidmode'] else arg for arg in args]
    print('Selected transition from method: %s' % ', '.join(args))


def _compose(mods, args):
    '''
    Compose a function
    
    @param  mods:[]                   Not used
    @param  args:list<str|list<str>>  The name of the function follow by the wrapped function and
                                      parameters wrappers: 'as-is' for identity, 'yes' for tautology,
                                      'no' for contradiction, and functions names for functions, or
                                      a composition
    '''
    args = evaluate_tree(args, False)
    new_function = args[0]
    old_function = composed[args[1]] if args[1] in composed else eval(args[1])
    arguments = [[arg] if isinstance(arg, str) else arg for arg in args[2:]]
    
    wrapping = []
    for arg in arguments:
        composite = lambda x : x()
        for f_ in arg:
            if f_ == 'as-is':
                continue
            elif f_ == 'yes':
                composite = lambda x : True
            elif f_ == 'no':
                composite = lambda x : False
            else:
                composite_ = composite
                f = composed[f_] if f_ in composed else eval(f_)
                composite = lambda x : f(composite_(x))
        wrapping.append(composite)
    
    def F_new(*args):
        arg_ptr = -1
        def arg_itr():
            nonlocal arg_ptr
            arg_ptr += 1
            return args[arg_ptr]
        evaled = []
        for wrap in wrapping:
            evaled.append(wrap(arg_itr))
        return old_function(*evaled)
    
    composed[new_function] = F_new


class Negative:
    '''
    Negative image adjustment
    '''
    def __init__(self):
        self.monitors = [(False, False, False, False, False, False)]
    def __call__(self, monitor, alpha):
        negative(*(self.monitors[monitor % len(self.monitors)][3 if alpha == 0 else 0:][:3]))

def _negative(mods, args):
    '''
    Add negative image adjustment
    
    @param  mods:list<str>                  'red', 'green' and 'blue' for restricting to those colour
                                            curves, and 'default' for using before and after Blueshift
                                            is running
    @param  args:list<[str, str, str]|str>  'yes' and 'no' or 3–tuple for red, green and blue, for each
                                            monitor (or all of them) on whether to apply negative image,
                                            'yes' implied for all monitors if empty
    '''
    red     = 'red'     in mods
    green   = 'green'   in mods
    blue    = 'blue'    in mods
    default = 'default' in mods
    args = evaluate_tree(args, True)
    prev = None if len(adjustments) == 0 else adjustments[-1]
    if (prev is None) or not isinstance(prev, Negative):
        prev = Negative()
        adjustments.append(prev)
    if not len(prev.monitors) == len(args):
        prev.monitors *= len(args)
        args *= len(prev.monitors) // len(args)
    if not any(red, green, blue):
        red = green = blue = True
    for monitor in range(len(args)):
        adj = args[monitor]
        if isinstance(adj, str):
            adj = [adj, adj, adj]
        adj = [(a == 'yes') && p for a, p in zip(adj, (red, green, blue))]
        adj = ([False] * 3 if default else []) + adj + ([] if default else [False] * 3)
        adj = [a ^ b for a, b in zip(adj, prev.monitors[monitor])]
        prev.monitors[monitor] = tuple(adj)


class RGBInvert:
    '''
    Colour inversion adjustment in sRBG
    '''
    def __init__(self):
        self.monitors = [(False, False, False, False, False, False)]
    def __call__(self, monitor, alpha):
        rgb_invert(*(self.monitors[monitor % len(self.monitors)][3 if alpha == 0 else 0:][:3]))

class CIEInvert:
    '''
    Colour inversion adjustment in CIE xyY
    '''
    def __init__(self):
        self.monitors = [(False, False, False, False, False, False)]
    def __call__(self, monitor, alpha):
        cie_invert(*(self.monitors[monitor % len(self.monitors)][3 if alpha == 0 else 0:][:3]))

def _invert(mods, args):
    '''
    Add colour inversion adjustment
    
    @param  mods:list<str>                  'red', 'green' and 'blue' for restricting to those colour
                                            curves, 'cie' for using CIE xyY and 'default' for using
                                            before and after Blueshift is running
    @param  args:list<[str, str, str]|str>  'yes' and 'no' or 3–tuple for red, green and blue, for each
                                            monitor (or all of them) on whether to apply colour invertion,
                                            'yes' implied for all monitors if empty
    '''
    cie     = 'cie'     in mods
    red     = 'red'     in mods
    green   = 'green'   in mods
    blue    = 'blue'    in mods
    default = 'default' in mods
    args = evaluate_tree(args, True)
    prev = None if len(adjustments) == 0 else adjustments[-1]
    if (prev is None) or not isinstance(prev, CIEInvert if cie else RGBInvert):
        prev = CIEInvert() if cie else RGBInvert()
        adjustments.append(prev)
    if not len(prev.monitors) == len(args):
        prev.monitors *= len(args)
        args *= len(prev.monitors) // len(args)
    if not any(red, green, blue):
        red = green = blue = True
    for monitor in range(len(args)):
        adj = args[monitor]
        if isinstance(adj, str):
            adj = [adj, adj, adj]
        adj = [(a == 'yes') && p for a, p in zip(adj, (red, green, blue))]
        adj = ([False] * 3 if default else []) + adj + ([] if default else [False] * 3)
        adj = [a ^ b for a, b in zip(adj, prev.monitors[monitor])]
        prev.monitors[monitor] = tuple(adj)


def _temperature(mods, args):
    '''
    Add colour temperature adjustment
    
    @param  mods:[]|[str]              'default' for using before and after Blueshift is running
    @param  args:list<[str]|list<str>  Temperature to apply all day long or depending
                                       on time, or either of those depending on monitor
    '''
    args = evaluate_tree(args, True)
    pass


def _current(mods, args):
    '''
    Add adjustments applied when Blueshift starts
    
    @param  mods:[]         Not used
    @param  args:list<str>  Method used to get the current adjustments, options for all monitors:
                            'randr' for `randr_get`, 'vidmode' for `vidmode_get` or 'nil' for none
    '''
    args = evaluate_tree(args, True)
    pass


def _brightness(mods, args):
    '''
    Add white point level adjustment
    
    @param  mods:list<str>                    'red', 'green' and 'blue' for restricting to those
                                              colour curves, 'cie' for using CIE xyY and 'default'
                                              for using before and after Blueshift is running
    @param  args:list<str|[str]               The adjustment at each time point, or all day long,
                     |[str, str, str]         optionally with individual colour curve control; or
                     |list<[str]>             the adjustment at each time point (outer) for each monitor,
                     |list<[str, str, str]>>  optionally with individual colour curve control
    '''
    args = evaluate_tree(args, True)
    pass


def _contrast(mods, args):
    '''
    Add black point–white point divergence level adjustment
    
    @param  mods:list<str>                    'red', 'green' and 'blue' for restricting to those
                                              colour curves, 'cie' for using CIE xyY and 'default'
                                              for using before and after Blueshift is running
    @param  args:list<str|[str]               The adjustment at each time point, or all day long,
                     |[str, str, str]         optionally with individual colour curve control; or
                     |list<[str]>             the adjustment at each time point (outer) for each monitor,
                     |list<[str, str, str]>>  optionally with individual colour curve control
    '''
    args = evaluate_tree(args, True)
    pass


def _resolution(mods, args):
    '''
    Add colour curve resolution adjustment
    
    @param  mods:list<str>                    'red', 'green' and 'blue' for restricting to those colour curves
                                              and 'default' for using before and after Blueshift is running,
                                              and 'output' for on the output axis, and 'encoding' for on the
                                              encoding axis.
    @param  args:list<str|[str]               The adjustment at each time point, or all day long,
                     |[str, str, str]         optionally with individual colour curve control; or
                     |list<[str]>             the adjustment at each time point (outer) for each monitor,
                     |list<[str, str, str]>>  optionally with individual colour curve control
    '''
    args = evaluate_tree(args, True)
    pass


def _gamma(mods, args):
    '''
    Add gamma correction adjustment
    
    @param  mods:list<str>                    'red', 'green' and 'blue' for restricting to those colour curves
                                              and 'default' for using before and after Blueshift is running
    @param  args:list<str|[str]               The adjustment at each time point, or all day long,
                     |[str, str, str]         optionally with individual colour curve control; or
                     |list<[str]>             the adjustment at each time point (outer) for each monitor,
                     |list<[str, str, str]>>  optionally with individual colour curve control
    '''
    args = evaluate_tree(args, True)
    pass


def _pgamma(mods, args):
    '''
    Add gamma correction adjustment without curve clipping
    
    @param  mods:list<str>                    'red', 'green' and 'blue' for restricting to those colour curves
                                              and 'default' for using before and after Blueshift is running
    @param  args:list<str|[str]               The adjustment at each time point, or all day long,
                     |[str, str, str]         optionally with individual colour curve control; or
                     |list<[str]>             the adjustment at each time point (outer) for each monitor,
                     |list<[str, str, str]>>  optionally with individual colour curve control
    '''
    args = evaluate_tree(args, True)
    pass


def _clip(mods, args):
    '''
    Add curve clipping adjustment
    
    @param  mods:list<str>                  'red', 'green' and 'blue' for restricting to those colour curves
    @param  args:list<[str, str, str]|str>  'yes' and 'no' or 3–tuple for red, green and blue, for each
                                            monitor (or all of them) on whether to clip the curve,
                                            'yes' implied for all monitors if empty
    '''
    args = evaluate_tree(args, True)
    pass


def _sigmoid(mods, args):
    '''
    Add sigmoid curve cancellation adjustment
    
    @param  mods:list<str>                    'red', 'green' and 'blue' for restricting to those colour curves
                                              and 'default' for using before and after Blueshift is running
    @param  args:list<str|[str]               The adjustment at each time point, or all day long,
                     |[str, str, str]         optionally with individual colour curve control; or
                     |list<[str]>             the adjustment at each time point (outer) for each monitor,
                     |list<[str, str, str]>>  optionally with individual colour curve control;
                                              'nil' for nothing
    '''
    red = 'red' in mods
    green = 'green' in mods
    blue = 'blue' in mods
    args = evaluate_tree(args, True)
    args = [[arg, arg, arg] if isinstance(arg, str) else arg for arg in args]
    args = [[None if a == 'nil' else float(a) for a in arg] for arg in args]
    if red or green or blue:
        args = [[arg[0] if red else None, arg[1] if green else None, arg[2] if blue else None] for arg in args]
    adjustments.append(lambda monitor : sigmoid(*(args[monitor % len(args)])))


def _limits(mods, args):
    '''
    Add sigmoid curve cancellation adjustment
    
    @param  mods:list<str>              red', 'green' and 'blue' for restricting to those colour curves,
                                        'cie' for using CIE xyY and 'default' for using before and after
                                        Blueshift is running
    @param  args:list<str>|             Add limitations all day long either [minimum, maximum], or
                                        [red minimum, red maximum, green minimum, green maximum,
                                        blue minimum, blue maximum], optionally
                 list<list<str>         optionally for each monitor (all if just one specified) (outer/middle),
                     |list<list<str>>   optionally at each time point (outer)
    '''
    args = evaluate_tree(args, True)
    pass # TODO (limits)


def _linearise(mods, args):
    '''
    Add sRGB to linear RGB conversion adjustment
    
    @param  mods:list<str>                  'red', 'green' and 'blue' for restricting to those colour curves
    @param  args:list<[str, str, str]|str>  'yes' and 'no' or 3–tuple for red, green and blue, for each
                                            monitor (or all of them) on whether to convert the curve,
                                            'yes' implied for all monitors if empty
    '''
    red = 'red' in mods
    green = 'green' in mods
    blue = 'blue' in mods
    args = evaluate_tree(args, True)
    args = [[arg, arg, arg] if isinstance(arg, str) else arg for arg in args]
    args = [[a == 'yes' for a in arg] for arg in args]
    if red or green or blue:
        args = [[arg[0] and red, arg[1] and green, arg[2] and blue] for arg in args]
    adjustments.append(lambda monitor : linearise(*(args[monitor % len(args)])))


def _icc(mods, args):
    '''
    Add adjustment by ICC profile
    
    @param  mods:[]|[str]             'filter' or 'calib' (default) for when Blueshift is running and
                                      Blueshift is running but also before and after, respectively
    @param  args:list<str|list<str>>  The ICC profile pathname for each time point (all day long if one),
                                      and optionally (inner) for each monitor.
    '''
    args = evaluate_tree(args, False)
    pass # TODO (icc)


def _manipulate(mods, args):
    '''
    Add curve manipulation function adjustment
    
    @param  mods:list<str>                  red', 'green' and 'blue' for restricting to those colour curves,
                                            'cie' for using CIE xyY and 'default' for using before and after
                                            Blueshift is running
    @param  args:list<[str, str, str]|str>  Function for each monitor (for all if just one specified), and
                                            optionally one per colour curve (red, green and blue)
    '''
    red = 'red' in mods
    green = 'green' in mods
    blue = 'blue' in mods
    args = evaluate_tree(args, False)
    args = [[arg, arg, arg] if isinstance(arg, str) else arg for arg in args]
    args = [[None if a == 'nil' else eval(a) for a in arg] for arg in args]
    if red or green or blue:
        args = [[arg[0] if red else None, arg[1] if green else None, arg[2] if blue else None] for arg in args]
    adjustments.append(lambda monitor : manipulate(*(args[monitor % len(args)])))


def _standardise(mods, args):
    '''
    Add linear RGB to sRGB conversion adjustment
    
    @param  mods:list<str>                  'red', 'green' and 'blue' for restricting to those colour curves
    @param  args:list<[str, str, str]|str>  'yes' and 'no' or 3–tuple for red, green and blue, for each
                                            monitor (or all of them) on whether to convert the curve,
                                            'yes' implied for all monitors if empty
    '''
    red = 'red' in mods
    green = 'green' in mods
    blue = 'blue' in mods
    args = evaluate_tree(args, True)
    args = [[arg, arg, arg] if isinstance(arg, str) else arg for arg in args]
    args = [[a == 'yes' for a in arg] for arg in args]
    if red or green or blue:
        args = [[arg[0] and red, arg[1] and green, arg[2] and blue] for arg in args]
    adjustments.append(lambda monitor : standardise(*(args[monitor % len(args)])))


# Map function names to functions
functions = { 'monitors'    : _monitors
            , 'crtc'        : _crtc
            , 'size'        : _size
            , 'edid'        : _edid
            , 'coordinates' : _coordinates
            , 'parse'       : _parse
            , 'read'        : _read
            , 'spawn'       : _spawn
            , 'include'     : _include
            , 'source'      : _source
            , 'eval'        : _eval
            , 'timepoints'  : _timepoints
            , 'points'      : _points
            , 'dayness'     : _dayness
            , 'method'      : _method
            , 'transfrom'   : _transfrom
            , 'negative'    : _negative
            , 'invert'      : _invert
            , 'temperature' : _temperature
            , 'compose'     : _compose
            , 'current'     : _current
            , 'brightness'  : _brightness
            , 'contrast'    : _contrast
            , 'resolution'  : _resolution
            , 'gamma'       : _gamma
            , '\'gamma'     : _pgamma
            , 'clip'        : _clip
            , 'sigmoid'     : _sigmoid
            , 'limits'      : _limits
            , 'linearise'   : _linearise
            , 'icc'         : _icc
            , 'manipulate'  : _manipulate
            , 'standardise' : _standardise
            }


def evaluate_tree(elements, implied_functions = True):
    '''
    Evaluate the tree
    
    @param  elements:list<↑|str>    Elements
    @param  implied_functions:bool  Whether to parse the first element as a function call
    '''
    rc = []
    if len(elements) == 0:
        return rc
    if elements[0] == '.':
        elements = elements[1:]
    else:
        if isinstance(elements[0], str):
            cand = elements[0].split(':')[0]
            if cand in functions.keys():
                elements = [':' + elements[0], elements[1:]]
    i, n = 0, len(elements)
    while i < n:
        element = elements[i]
        if isinstance(element, str) and element.startswith(':'):
            if i + 1 < len(elements):
                args = elements[i + 1]
                i += 1
                if isinstance(args, str):
                    args = [args]
                element = element[1:].split(':')
                ret = functions[element[0]](element[1:], args)
                if ret is not None:
                    rc += ret
        else:
            if not isinstance(element, str):
                element = evaluate_tree(element, implied_functions)
            if element is not None:
                rc.append(element)
        i += 1
    return rc


# Evaluate tree
evaluate_tree(conf, True)
conf = None

